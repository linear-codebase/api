# Rules Summary

## 1. Commits (Conventional Commits)

- **Format**: All commit messages must follow the structure: `<type>[optional scope]: <description>`. An optional body and footer can follow after a blank line.
- **Types**: Use `feat` for new features and `fix` for bug fixes. Other types like `docs`, `style`, `refactor`, `test`, `chore`, `ci`, and `perf` are recommended.
- **Breaking Changes**: Indicate breaking changes with a `!` after the type/scope (e.g., `feat(api)!:`) or a `BREAKING CHANGE:` section in the footer.
- **Structure**: The type prefix is mandatory and must be followed by a colon and a space.

## 2. General Principles

- **Core Tenets**: Strive for zero-configuration, sub-second performance, maximum type safety, and AI-friendly code generation.
- **Process**: Before writing code, analyze existing patterns, consider edge cases, and strictly follow all established rules and accessibility requirements.

## 3. Code Quality & Style

### Accessibility (a11y)
- Enforce strict accessibility standards. Use semantic elements over role attributes.
- Ensure correct usage of ARIA roles, states, and properties.
- All interactive elements must be focusable and have accessible names.
- Provide meaningful alt text for images and titles for SVGs and iframes.
- Do not use distracting elements like `<marquee>` or `<blink>`.

### Complexity & Quality
- Write simple, efficient, and modern code. Avoid unnecessary constructs (e.g., `arguments`, comma operator, redundant blocks, unnecessary `else` clauses).
- Refactor overly complex functions and deeply nested blocks.
- Prefer modern syntax and methods like optional chaining, `flatMap`, arrow functions, and `for...of` loops over `forEach`.

### Correctness & Safety
- Eliminate unreachable code, unused variables, parameters, and imports.
- Prevent common errors like variable shadowing, import cycles, and unsafe operations.
- Handle promises correctly and do not use `await` inside loops.
- Use strict equality (`===` and `!==`).
- Do not use `@ts-ignore`, `eval`, or the `delete` operator.

### TypeScript
- Enforce strict and modern TypeScript usage. Do not use `any`, `enum`, or `namespace`.
- Avoid non-null assertions (`!`).
- Prefer `as const` over literal types. Use `import type` and `export type` for type-only imports/exports.

### React & JSX
- Adhere strictly to React best practices, especially the Rules of Hooks.
- Always provide unique `key` props in iterators. Do not use array indexes as keys.
- Do not define React components inside other components.
- Avoid using dangerous props like `dangerouslySetInnerHTML`.

### Testing
- Write clean and focused tests. Do not commit focused (`.only`) or disabled (`.skip`) tests.
- Do not use `export` or `module.exports` within test files.

## 4. Elysia Framework

### Architecture & Structure
- Treat every Elysia instance as a reusable component (plugin).
- Always use method chaining to ensure type integrity and inference.
- Use a feature-based folder structure (e.g., `modules/feature/{index.ts, service.ts, model.ts}`).
- The Elysia instance itself should serve as the controller; do not create separate controller classes.
- Decouple business logic into services. Services that are not request-dependent should be static.
- Name plugins (`new Elysia({ name: '...' })`) to enable automatic deduplication.

### Type Safety & Models
- Use `Elysia.t` or another supported schema builder for all models (DTOs). Do not use classes or interfaces for validation schemas.
- A schema must be the single source of truth for runtime validation, TypeScript types, and OpenAPI documentation.
- Derive TypeScript types directly from schemas using `typeof schema.static`.
- Use reference models via `.model({ name: schema })` for reusability, organization, and improved type inference performance.

### Context & State
- Be explicit about the scope of lifecycle hooks (`{ as: 'local' | 'scoped' | 'global' }`).
- Use `state` for global, mutable values shared across the app, accessible via `store`.
- Use `decorate` to add request-agnostic, read-only properties (like singletons or helper functions) to the context.
- Use `derive` (runs before validation) and `resolve` (runs after validation) to add request-specific properties that are computed from the existing context.
